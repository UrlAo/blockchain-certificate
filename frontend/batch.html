<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ‰¹é‡ç™»è®° - åŒºå—é“¾è¯ä¹¦ç³»ç»Ÿ</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="config.js"></script>
  <link rel="stylesheet" href="styles.css?v=20251121">
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="title">ğŸ“¦ æ‰¹é‡ç™»è®°ï¼ˆMerkle Rootï¼‰</div>
      <div class="status">
        <button class="link-btn" onclick="location.href='index.html'">è¿”å›é¦–é¡µ</button>
        <span id="netBadge" class="badge" style="display:none"></span>
      </div>
    </div>

    <div class="card" id="submitCard">
      <h3>æ­¥éª¤ 1ï¼šé€‰æ‹©æ‰¹é‡æ–‡ä»¶</h3>
      <input type="file" id="files" multiple accept=".pdf,.jpg,.jpeg,.png" />
      <div class="row">
        <button class="btn-primary" onclick="computeRoot()">è®¡ç®— Merkle Root</button>
      </div>
      <div id="rootBox"></div>
    </div>

    <div class="card">
      <h3>æ­¥éª¤ 2ï¼šæäº¤ Root åˆ°åŒºå—é“¾</h3>
      <div class="field"><label for="batchId">æ‰¹æ¬¡æ ‡è¯†</label><input class="input" id="batchId" placeholder="ä¾‹å¦‚: 2025-æ¯•ä¸šæ‰¹æ¬¡"></div>
      <div class="row">
        <button class="btn-primary" onclick="submitRoot()" id="submitBtn" disabled>æäº¤ Root</button>
      </div>
      <div id="status" class="hint"></div>
    </div>

    <div class="card" id="proofCard">
      <h3>æ­¥éª¤ 3ï¼šå•æ–‡ä»¶è¯æ˜éªŒè¯</h3>
      <div class="field"><label for="proofFile">é€‰æ‹©æ–‡ä»¶ç”Ÿæˆè¯æ˜</label><input type="file" id="proofFile" accept=".pdf,.jpg,.jpeg,.png" /></div>
      <div class="row">
        <button class="btn-secondary" onclick="genAndVerifyProof()" id="proofBtn" disabled>ç”Ÿæˆå¹¶éªŒè¯è¯æ˜</button>
      </div>
      <div id="proofBox"></div>
    </div>
  </div>

  <script>
    let provider, signer, contract
    let leaves = []
    let root = ''
    
    async function init(){
      if (typeof window.ethereum === 'undefined') { alert('è¯·å®‰è£…MetaMask'); return }
      provider = new ethers.providers.Web3Provider(window.ethereum)
      await provider.send('eth_requestAccounts', [])
      signer = provider.getSigner()
      const network = await provider.getNetwork()
      const netBadge = document.getElementById('netBadge')
      netBadge.style.display = 'inline-block'
      netBadge.innerText = `chainId: ${network.chainId}`
      const res = await fetch(CONFIG.ABI_URL)
      const abi = await res.json()
      contract = new ethers.Contract(CONFIG.CONTRACT_ADDRESS.trim(), abi, signer)
      updateButtons()
    }

    async function computeSha256(file){
      const buf = await file.arrayBuffer()
      const hashBuf = await crypto.subtle.digest('SHA-256', buf)
      const hashArray = Array.from(new Uint8Array(hashBuf))
      return '0x' + hashArray.map(b=>b.toString(16).padStart(2,'0')).join('')
    }

    function keccak(dataHex){
      return ethers.utils.keccak256(dataHex)
    }

    async function computeRoot(){
      const input = document.getElementById('files')
      if (!input.files.length) { alert('è¯·é€‰æ‹©æ–‡ä»¶'); return }
      leaves = []
      for (let f of input.files){
        const sha = await computeSha256(f)
        // å¶å­ä½¿ç”¨ SHA-256ï¼ˆhexï¼‰ä½œä¸ºåŸå§‹å€¼ï¼Œå† keccak åšæ ‘è¿ç®—
        const leaf = keccak(sha)
        leaves.push(leaf)
      }
      if (leaves.length === 1){ root = leaves[0] }
      else {
        let level = leaves.slice()
        while (level.length > 1){
          const next = []
          for (let i = 0; i < level.length; i += 2){
            const left = level[i]
            const right = (i+1 < level.length) ? level[i+1] : level[i]
            const pair = (left.toLowerCase() <= right.toLowerCase()) ? left + right.substr(2) : right + left.substr(2)
            next.push(ethers.utils.keccak256(pair))
          }
          level = next
        }
        root = level[0]
      }
      document.getElementById('rootBox').innerHTML = `<div class="card"><div class="row"><strong>Merkle Root</strong><button class="btn-secondary" onclick=\"copyText('${root}')\">å¤åˆ¶</button></div><div class="code">${root}</div></div>`
      document.getElementById('submitBtn').disabled = false
      updateButtons()
    }

    async function submitRoot(){
      if (!contract) await init()
      const batchId = document.getElementById('batchId').value.trim() || ''
      try{
        document.getElementById('status').innerHTML = '<div class="card info">æäº¤ä¸­...</div>'
        const tx = await contract.issueBatchRoot(root, batchId)
        await tx.wait()
        document.getElementById('status').innerHTML = '<div class="card success">æäº¤æˆåŠŸ</div>'
      }catch(e){
        document.getElementById('status').innerHTML = `<div class="card error">æäº¤å¤±è´¥: ${e.message}</div>`
      }
    }

    function buildProofFor(index){
      // ç®€åŒ–ï¼šé‡æ–°æŒ‰ leaves é¡ºåºæ„å»ºè¯æ˜ï¼ˆæ¼”ç¤ºç”¨é€”ï¼‰
      let level = leaves.slice()
      const proof = []
      let idx = index
      while (level.length > 1){
        const isRight = idx % 2 === 1
        const pairIdx = isRight ? idx - 1 : idx + 1
        const sibling = level[pairIdx] || level[idx]
        proof.push(sibling)
        const next = []
        for (let i = 0; i < level.length; i += 2){
          const left = level[i]
          const right = (i+1 < level.length) ? level[i+1] : level[i]
          const pair = (left.toLowerCase() <= right.toLowerCase()) ? left + right.substr(2) : right + left.substr(2)
          next.push(ethers.utils.keccak256(pair))
        }
        level = next
        idx = Math.floor(idx/2)
      }
      return proof
    }

    async function genAndVerifyProof(){
      const pf = document.getElementById('proofFile')
      if (!pf.files.length){ alert('è¯·é€‰æ‹©æ–‡ä»¶'); return }
      const sha = await computeSha256(pf.files[0])
      const leaf = keccak(sha)
      const idx = leaves.indexOf(leaf)
      if (idx === -1){
        document.getElementById('proofBox').innerHTML = '<div class="card warn">è¯¥æ–‡ä»¶ä¸åœ¨å½“å‰æ‰¹æ¬¡</div>'
        return
      }
      const proof = buildProofFor(idx)
      const ok = await contract.verifyLeaf(root, leaf, proof)
      document.getElementById('proofBox').innerHTML = ok ? '<div class="card success">âœ… è¯æ˜éªŒè¯é€šè¿‡</div>' : '<div class="card error">âŒ è¯æ˜éªŒè¯å¤±è´¥</div>'
    }

    function updateButtons(){
      const submitBtn = document.getElementById('submitBtn')
      const submitCard = document.getElementById('submitCard')
      const proofBtn = document.getElementById('proofBtn')
      const proofCard = document.getElementById('proofCard')
      const pf = document.getElementById('proofFile')

      const canSubmit = Boolean(root) && Boolean(contract)
      const canProof = Boolean(root) && pf && pf.files && pf.files.length > 0

      submitBtn.classList.toggle('enabled', canSubmit)
      submitCard.classList.toggle('enabled', canSubmit)
      submitCard.classList.toggle('disabled', !canSubmit)

      proofBtn.disabled = !canProof
      proofBtn.classList.toggle('enabled', canProof)
      proofCard.classList.toggle('enabled', canProof)
      proofCard.classList.toggle('disabled', !canProof)
    }

    const pfInput = document.getElementById('proofFile')
    if (pfInput) pfInput.addEventListener('change', updateButtons)

    function copyText(text){ navigator.clipboard.writeText(text).catch(()=>{}) }
    window.onload = init
  </script>
</body>
</html>