<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‘è¡Œè¯ä¹¦ - åŒºå—é“¾è¯ä¹¦ç³»ç»Ÿ</title>
   <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
   <script src="config.js"></script>
   <link rel="stylesheet" href="styles.css">
    <style>
        .form-group { margin-bottom: 12px; }
        input { width: 100%; }
    </style>
</head>
<body>
    <div class="container">
      <div class="header">
        <div class="title">ğŸ“ å‘è¡Œè¯ä¹¦</div>
        <div class="status">
          <button class="link-btn" onclick="location.href='index.html'">è¿”å›é¦–é¡µ</button>
          <button id="connectBtn" class="btn-primary" onclick="connectWallet()">è¿æ¥é’±åŒ…</button>
          <span id="walletBadge" class="badge" style="display:none"></span>
        </div>
      </div>
      <div class="card">
        <h3>æ­¥éª¤ 1ï¼šé€‰æ‹©è¯ä¹¦æ–‡ä»¶å¹¶è®¡ç®—å“ˆå¸Œ</h3>
        <div id="dropZone" class="uploader">æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤æˆ–ç‚¹å‡»ä¸‹æ–¹é€‰æ‹©</div>
        <div class="form-group">
          <input type="file" id="certFile" accept=".pdf,.jpg,.jpeg,.png">
        </div>
        <div class="row">
          <button class="btn-secondary" onclick="calculateHash()">è®¡ç®—æ–‡ä»¶å“ˆå¸Œ</button>
        </div>
        <div id="hashResult"></div>
      </div>
      <div class="card">
        <h3>æ­¥éª¤ 2ï¼šå¡«å†™è¯ä¹¦ä¿¡æ¯</h3>
        <div class="grid">
          <div class="field"><label for="studentId">å­¦å·</label><input class="input" type="text" id="studentId" placeholder="ä¾‹å¦‚: 202301001"></div>
          <div class="field"><label for="studentName">å­¦ç”Ÿå§“å</label><input class="input" type="text" id="studentName" placeholder="ä¾‹å¦‚: å¼ ä¸‰"></div>
        </div>
        <div class="field"><label for="degree">å­¦ä½ä¿¡æ¯</label><input class="input" type="text" id="degree" placeholder="ä¾‹å¦‚: è®¡ç®—æœºç§‘å­¦å­¦å£«"></div>
        <div class="field"><label for="cid">IPFS CIDï¼ˆå¯é€‰ï¼‰</label><input class="input" type="text" id="cid" placeholder="ä¾‹å¦‚: bafy..."></div>
      </div>
      <div class="card">
        <h3>æ­¥éª¤ 3ï¼šå‘è¡Œåˆ°åŒºå—é“¾</h3>
        <div class="row">
          <button id="issueBtn" class="btn-primary" onclick="issueCertificate()" disabled>å‘è¡Œè¯ä¹¦åˆ°åŒºå—é“¾</button>
          <button class="btn-secondary" onclick="revokeCurrentCertificate()">æ’¤é”€å½“å‰è¯ä¹¦</button>
          <button class="btn-secondary" onclick="issueWithSignature()">ç­¾åå‘è¡Œ</button>
        </div>
        <div id="status" class="hint"></div>
      </div>
    </div>

    <script>
        let currentFileHash = '';
        let provider, signer, contract;
        let currentAccount = '';
        const LOCAL_CHAIN_ID_HEX = '0x7A69';
        const LOCAL_RPC_URL = 'http://127.0.0.1:8545';
        const contractAddress = '0x5FbDB2315678afecb367f032d93F642f64180aa3'; // éƒ¨ç½²åæ›¿æ¢ä¸ºå®é™…åœ°å€
        const contractABI = [  {
    "inputs": [],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "certHash",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "studentId",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "studentName",
        "type": "string"
      }
    ],
    "name": "CertificateIssued",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "certHash",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "internalType": "bool",
        "name": "isValid",
        "type": "bool"
      }
    ],
    "name": "CertificateVerified",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "admin",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "name": "certificates",
    "outputs": [
      {
        "internalType": "string",
        "name": "studentId",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "studentName",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "degree",
        "type": "string"
      },
      {
        "internalType": "uint256",
        "name": "issueDate",
        "type": "uint256"
      },
      {
        "internalType": "bool",
        "name": "isIssued",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "_certHash",
        "type": "bytes32"
      },
      {
        "internalType": "string",
        "name": "_studentId",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "_studentName",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "_degree",
        "type": "string"
      }
    ],
    "name": "issueCertificate",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "_certHash",
        "type": "bytes32"
      }
    ],
    "name": "simpleVerify",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "_certHash",
        "type": "bytes32"
      }
    ],
    "name": "verifyCertificate",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      },
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  } ];

        // åˆå§‹åŒ–ä»¥å¤ªåŠè¿æ¥
        async function initEthereum() {
            if (typeof window.ethereum !== 'undefined') {
                const currentChain = await window.ethereum.request({ method: 'eth_chainId' });
                if (currentChain !== LOCAL_CHAIN_ID_HEX) {
                    try {
                        await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: LOCAL_CHAIN_ID_HEX }] });
                    } catch (e) {
                        if (e && e.code === 4902) {
                            await window.ethereum.request({ method: 'wallet_addEthereumChain', params: [{ chainId: LOCAL_CHAIN_ID_HEX, chainName: 'Hardhat Local', rpcUrls: [LOCAL_RPC_URL], nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 } }] });
                        }
                    }
                }
                provider = new ethers.providers.Web3Provider(window.ethereum);
                await provider.send('eth_requestAccounts', []);
                signer = provider.getSigner();
                await loadAbiIfNeeded();
                const abiToUse = window.contractABI || contractABI;
                const addrToUse = ((typeof CONFIG !== 'undefined' && CONFIG.CONTRACT_ADDRESS) ? CONFIG.CONTRACT_ADDRESS : contractAddress).trim();
                contract = new ethers.Contract(addrToUse, abiToUse, signer);
                console.log("ä»¥å¤ªåŠè¿æ¥åˆå§‹åŒ–æˆåŠŸ");
                updateIssueBtnState();
                try {
                    const network = await provider.getNetwork();
                    const addr = await signer.getAddress();
                    currentAccount = addr;
                    const badge = document.getElementById('walletBadge');
                    badge.style.display = 'inline-block';
                    badge.innerText = `å·²è¿æ¥: ${addr.slice(0,6)}...${addr.slice(-4)} | chainId: ${network.chainId}`;
                    await showAccountDetails();
                } catch (_) {}
            } else {
                alert('è¯·å®‰è£…MetaMask!');
            }
        }

        async function connectWallet() {
            if (typeof window.ethereum === 'undefined') { alert('è¯·å®‰è£…MetaMask!'); return; }
            const currentChain = await window.ethereum.request({ method: 'eth_chainId' });
            if (currentChain !== LOCAL_CHAIN_ID_HEX) {
                try {
                    await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: LOCAL_CHAIN_ID_HEX }] });
                } catch (e) {
                    if (e && e.code === 4902) {
                        await window.ethereum.request({ method: 'wallet_addEthereumChain', params: [{ chainId: LOCAL_CHAIN_ID_HEX, chainName: 'Hardhat Local', rpcUrls: [LOCAL_RPC_URL], nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 } }] });
                    }
                }
            }
            provider = new ethers.providers.Web3Provider(window.ethereum);
            await provider.send('eth_requestAccounts', []);
            signer = provider.getSigner();
            await loadAbiIfNeeded();
            const abiToUse = window.contractABI || contractABI;
            const addrToUse = ((typeof CONFIG !== 'undefined' && CONFIG.CONTRACT_ADDRESS) ? CONFIG.CONTRACT_ADDRESS : contractAddress).trim();
            contract = new ethers.Contract(addrToUse, abiToUse, signer);
            try {
                const network = await provider.getNetwork();
                const addr = await signer.getAddress();
                currentAccount = addr;
                const badge = document.getElementById('walletBadge');
                badge.style.display = 'inline-block';
                badge.innerText = `å·²è¿æ¥: ${addr.slice(0,6)}...${addr.slice(-4)} | chainId: ${network.chainId}`;
                await showAccountDetails();
            } catch (_) {}
            updateIssueBtnState();
        }

        // è®¡ç®—æ–‡ä»¶å“ˆå¸Œ
        async function calculateHash() {
            const fileInput = document.getElementById('certFile');
            if (!fileInput.files[0]) {
                alert('è¯·é€‰æ‹©æ–‡ä»¶');
                return;
            }

            const file = fileInput.files[0];
            const arrayBuffer = await file.arrayBuffer();
            
            // è®¡ç®—SHA-256å“ˆå¸Œ
            const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            currentFileHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            
            document.getElementById('hashResult').innerHTML = 
                `<div class="card"><div class="row"><strong>æ–‡ä»¶å“ˆå¸Œå€¼</strong><button class="btn-secondary" onclick=\"copyText('${currentFileHash}')\">å¤åˆ¶</button></div><div class="code">${currentFileHash}</div></div>`;
            updateIssueBtnState();
        }

        // å‘è¡Œè¯ä¹¦
        async function issueCertificate() {
            if (!contract) {
                alert('è¯·å…ˆè¿æ¥é’±åŒ…');
                return;
            }
            if (!currentFileHash) {
                alert('è¯·å…ˆè®¡ç®—æ–‡ä»¶å“ˆå¸Œ');
                return;
            }

            const studentId = document.getElementById('studentId').value;
            const studentName = document.getElementById('studentName').value;
            const degree = document.getElementById('degree').value;

            if (!studentId || !studentName || !degree) {
                alert('è¯·å¡«å†™æ‰€æœ‰ä¿¡æ¯');
                return;
            }

            try {
                const hashBytes32 = '0x' + currentFileHash;
                const existing = await contract.getCertificate(hashBytes32);
                if (existing && existing[0]) {
                    const issuedAt = new Date(Number(existing[4]) * 1000).toLocaleString();
                    document.getElementById('status').innerHTML = `<div class="card warn">è¯ä¹¦å·²å­˜åœ¨ï¼Œæ— æ³•é‡å¤å‘è¡Œ<br>å­¦å·: ${existing[1]} | å§“å: ${existing[2]} | å­¦ä½: ${existing[3]} | æ—¶é—´: ${issuedAt}</div>`;
                    return;
                }

                document.getElementById('status').innerHTML = '<div class="card info">æ­£åœ¨å‘è¡Œè¯ä¹¦...</div>';
                document.getElementById('issueBtn').disabled = true;

                const cid = document.getElementById('cid').value.trim();
                let tx;
                if (cid && typeof contract.issueCertificateWithCid === 'function') {
                  tx = await contract.issueCertificateWithCid(hashBytes32, studentId, studentName, degree, cid);
                } else {
                  tx = await contract.issueCertificate(hashBytes32, studentId, studentName, degree);
                }
                document.getElementById('status').innerHTML = `<div class="card info">äº¤æ˜“å·²æäº¤ï¼Œç­‰å¾…ç¡®è®¤<br>txHash: <span class="code">${tx.hash}</span> <button class="btn-secondary" onclick=\"copyText('${tx.hash}')\">å¤åˆ¶</button></div>`;

                await tx.wait();
                document.getElementById('status').innerHTML = '<div class="card success">âœ… è¯ä¹¦å‘è¡ŒæˆåŠŸï¼</div>';
                document.getElementById('issueBtn').disabled = false;

            } catch (error) {
                document.getElementById('status').innerHTML = `<div class="card error">âŒ å‘è¡Œå¤±è´¥: ${error.message}</div>`;
                document.getElementById('issueBtn').disabled = false;
            }
        }

        function updateIssueBtnState() {
            const canIssue = Boolean(currentFileHash) && Boolean(contract);
            document.getElementById('issueBtn').disabled = !canIssue;
        }

        async function showAccountDetails(){
            try{
                const bal = await provider.getBalance(currentAccount);
                const adminAddr = await contract.admin();
                const isAdmin = adminAddr.toLowerCase() === currentAccount.toLowerCase();
                const status = document.getElementById('status');
                status.innerHTML = `<div class="card info">ä½™é¢: ${Number(ethers.utils.formatEther(bal)).toFixed(4)} ETH | æƒé™: ${isAdmin? 'ç®¡ç†å‘˜':'éç®¡ç†å‘˜'}${isAdmin? '':'ï¼ˆä»…ç®¡ç†å‘˜å¯å‘è¡Œï¼‰'}</div>`;
            }catch(_){}
        }

        function copyText(text){
            navigator.clipboard.writeText(text).catch(()=>{});
        }

        const dropZone = document.getElementById('dropZone');
        if(dropZone){
          ['dragenter','dragover'].forEach(evt=>dropZone.addEventListener(evt,e=>{e.preventDefault();dropZone.classList.add('drag')}));
          ['dragleave','drop'].forEach(evt=>dropZone.addEventListener(evt,e=>{e.preventDefault();dropZone.classList.remove('drag')}));
          dropZone.addEventListener('drop', async (e)=>{
              const f = e.dataTransfer.files && e.dataTransfer.files[0];
              if(!f) return;
              document.getElementById('certFile').files = e.dataTransfer.files;
              await calculateHash();
          });
        }

        // æ’¤é”€è¯ä¹¦ï¼ˆç®¡ç†å‘˜ï¼‰
        async function revokeCurrentCertificate(){
            if (!contract) { alert('è¯·å…ˆè¿æ¥é’±åŒ…'); return; }
            if (!currentFileHash) { alert('è¯·å…ˆè®¡ç®—æ–‡ä»¶å“ˆå¸Œ'); return; }
            const reason = prompt('è¯·è¾“å…¥æ’¤é”€åŸå› ');
            if (reason === null) return;
            try{
                document.getElementById('status').innerHTML = '<div class="card warn">æ­£åœ¨æ’¤é”€è¯ä¹¦...</div>';
                const hashBytes32 = '0x' + currentFileHash;
                const tx = await contract.revokeCertificate(hashBytes32, reason);
                await tx.wait();
                document.getElementById('status').innerHTML = '<div class="card success">å·²æ’¤é”€è¯ä¹¦</div>';
            }catch(e){
                document.getElementById('status').innerHTML = `<div class="card error">æ’¤é”€å¤±è´¥: ${e.message}</div>`;
            }
        }

        async function issueWithSignature(){
            if (!contract) { alert('è¯·å…ˆè¿æ¥é’±åŒ…'); return; }
            if (!currentFileHash) { alert('è¯·å…ˆè®¡ç®—æ–‡ä»¶å“ˆå¸Œ'); return; }
            const studentId = document.getElementById('studentId').value;
            const studentName = document.getElementById('studentName').value;
            const degree = document.getElementById('degree').value;
            const cid = document.getElementById('cid').value.trim();
            if (!studentId || !studentName || !degree) { alert('è¯·å¡«å†™æ‰€æœ‰ä¿¡æ¯'); return; }
            try{
                const hashBytes32 = '0x' + currentFileHash;
                const existing = await contract.getCertificate(hashBytes32);
                if (existing && existing[0]){
                    const issuedAt = new Date(Number(existing[4]) * 1000).toLocaleString();
                    document.getElementById('status').innerHTML = `<div class="card warn">è¯ä¹¦å·²å­˜åœ¨ï¼Œæ— æ³•ç­¾åé‡å¤å‘è¡Œ<br>å­¦å·: ${existing[1]} | å§“å: ${existing[2]} | å­¦ä½: ${existing[3]} | æ—¶é—´: ${issuedAt}</div>`;
                    return;
                }
                const addr = await signer.getAddress();
                const nonce = await contract.nonces(addr);
                const types = {
                    Certificate: [
                        { name: 'certHash', type: 'bytes32' },
                        { name: 'studentId', type: 'string' },
                        { name: 'studentName', type: 'string' },
                        { name: 'degree', type: 'string' },
                        { name: 'ipfsCid', type: 'string' },
                        { name: 'nonce', type: 'uint256' }
                    ]
                };
                const value = {
                    certHash: hashBytes32,
                    studentId,
                    studentName,
                    degree,
                    ipfsCid: cid,
                    nonce: Number(nonce)
                };
                const domain = {
                    name: 'CertificateRegistry',
                    version: '1',
                    chainId: (await provider.getNetwork()).chainId,
                    verifyingContract: contract.address
                };
                const sig = await signer._signTypedData(domain, types, value);
                document.getElementById('status').innerHTML = '<div class="card info">ç­¾åå®Œæˆï¼Œæäº¤äº¤æ˜“...</div>';
                const tx = await contract.issueWithSig(value.certHash, studentId, studentName, degree, cid, Number(nonce), sig);
                await tx.wait();
                document.getElementById('status').innerHTML = '<div class="card success">ç­¾åå‘è¡ŒæˆåŠŸ</div>';
            }catch(e){
                document.getElementById('status').innerHTML = `<div class="card error">ç­¾åå‘è¡Œå¤±è´¥: ${e.message}</div>`;
            }
        }

        async function loadAbiIfNeeded() {
            try {
                if (!window.contractABI && typeof CONFIG !== 'undefined' && CONFIG.ABI_URL) {
                    const res = await fetch(CONFIG.ABI_URL);
                    window.contractABI = await res.json();
                }
            } catch (e) {
                console.warn('åŠ è½½ ABI å¤±è´¥ï¼Œä½¿ç”¨å†…ç½® ABI', e);
            }
        }

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        window.onload = initEthereum;
    </script>
</body>
</html>